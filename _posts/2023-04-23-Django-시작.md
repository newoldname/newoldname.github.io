## 장고 프로젝트 생성하기
```sh
django-admin startproject django_project .    # 점(".")이 굉장히 중요
```

### 장고 프로젝트 시간 설정
```python
# in ./projectName/Settings.py
...
LANGUAGE_CODE = "en-us"

TIME_ZONE = "Asia/Seoul"

USE_TZ = False
...
```

프로젝트 이름은 알파벳, 숫자, _만 가능한 것으로 추측(-로 했는데 안됨.)

## 서버 시작

```sh
python3 manage.py runserver
```

## DB 구조 반영하기

```sh
python3 manage.py makemigrations 
python3 manage.py migrate
```

## 슈퍼 유저 만들기

```sh
 python3 manage.py createsuperuser 필요한 값들을 채우기
```
 
## 장고의 앱 개념
프로젝트 안에 구체적인 기능으로 분리되는 여러 앱들이 있다. 
- 회원관리앱
- 상품관리앱
- 등등

> 기본적으로 설정되어 있는 앱들은 ./프로젝트명/Settings.py안에 있다. 
 
## 장고 앱 만들기

```sh
python3 manage.py startapp blog
python3 manage.py startapp single_pages
```

```python
# in ./projectName/Settings.py
INSTALLED_APPS = [
	...
	...
	'blog', 
	'single_pages',
]
```

## 장고 모델 만들기(테이블 만들기)
### 파이썬에서 모델 코드 작성(모델 만들기)
```python
# in ./{projectName}/{AppName}/models.py
...
from django.db import models
class Post(models.Model):
    title = models.CharField(max_length=30)
    content = models.TextField()

    created_at = models.DateTimeField()
    
    # 객체 안에서 원하는 함수를 작성할 수 있음
    def __str__(self):
        return f"[{self.pk}]{self.title}"
...
```
### 수정된 모델들을 장고에 알려주기

```sh
python3 manage.py makemigrations
python3 manage.py migrate
```

> migrate를 실행하면 해당 앱에서 migrations라는 폴더가 생성되는데, 이걸 .gitignore에 추가해서 무시하면 좋다. 
> 새로운 줄에서 `migrations/`라고 작성하면 된다. 

### admin이 백에서 관리할 수 있도록 /admin 페이지에 추가하기

```python
...
from django.contrib import admin
from blog.models import Post

# Register your models here.
admin.site.register(Post)
...
```

## 장고 모델 설정 함수들
### 시간 필드의 현재 시간 / 작성 시간 자동 추가

```python
# in ./{projectName}/{AppName}/models.py
...
from django.db import models
class Post(models.Model):
    title = models.CharField(max_length=30)
    content = models.TextField()
    
    # 여기 주우우우우우우우우우우우우우목
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    # 여기 주우우우우우우우우우우우우우목
    
    # 객체 안에서 원하는 함수를 작성할 수 있음
    def __str__(self):
        return f"[{self.pk}]{self.title}"
...
```

## Url 관련 개념(+FVB, CVB)

- 프로젝트 폴더의 urls.py를 통해 Url들이 결정된다. 

### FVB스타일로 게시물 기능 만들기
- 프로젝트의 urls.py
-  -> 해당 앱의 urls.py
-  -> 해당 앱의 views.py를 통해 해야 할 작업을 함수로 실행하고, 
-  -> 결과물을 html파일에 랜더링한 뒤 반환한다. 

### CVB스타일로 게시물 기능 만들기
- 프로젝트의 urls.py
-  -> 해당 앱의 urls.py
-  -> 해당 앱의 views.py를 통해 해야 할 작업을 미리 정의된 클래스로 실행하고, 
-  -> 결과물을 html파일에 랜더링한 뒤 반환한다. 

## urls.py: url의 경로 설정하기
### 다른 urls.py를 포함하고 싶을 때

```python
from django.contrib import admin
from django.urls import path, include # include를 import해야 합니다.

urlpatterns = [
    path('blog/', include('blog.urls')), # 마지막 콤마(",") 주의
    # path('something/', include('{appName}.urls')), -> go to appName/urls.py
    
    path('admin/', admin.site.urls),
]
```

### url경로의 변수(파라미터)를 설정하고 싶을 때
- 먼저 urls.py파일에서 이렇게 설정하세요

```python
from django.urls import path
from blog import views

urlpatterns = [
    # <자료형:변수 이름>으로 url경로에 사용하면 된다.
    path("<int:pk>/", views.single_post_page),
    path("", views.index),
]
```

- 그리고 해당 views의 함수의 인자에 위에서 만든 변수 이름을 추가하세요

```python
def single_post_page(request, pk):
	#do something...
```

### CVB로 할 때

```python
urlpatterns = [
    path("<int:pk>/", views.PostList.as_view(), # 해당 클래스의 함수를 바로 사용하기
]
```

## views.py: url에 연결할 기능 만들기
### FVB: 해당 기능을 함수로 직접 만들기
**모든 게시물을 조회해서 반환하는 기능 만들기**

```python
# Location: /{appName}/views.py
from django.shortcuts import render
from blog.models import Post

def index(request):
    # posts = Post.objects.all()
    posts = Post.objects.all().order_by("-pk")

    return render(
        request,
        "blog/index.html",
        {
            "posts": posts,
        },
    )
```

### CVB: 클래스를 상속해 만들어진 함수 사용하기
```python
# Location: /{appName}/views.py
from django.views.generic import ListView, DetailView
from blog.models import Post

class PostList(ListView):
    model = Post
    # 기본적으로 해당 클래스는 "{모델명}_list.html"을 사용하고.
    # 랜더링할 변수 이름도 단순히 posts가 아닌 "{모델명}_list"이다.
    # 만약에 템플릿 을 강제로 지정하고 싶으면
    # template_name = 'blog/index.html'

class PostDetail(DetailView):
    model = Post

```

## templates: views에서 랜더링할 파일들
1. 폴더 만들기: `./{project_name}/{app_name}/templates/원하는 방식대로`
2. views.py의 render함수의 두번째 인자에서 `{원하는 방식대로}` 경로만 작성하면 된다.(`.../templates/`까지의 경로ㅍ무시)

```python
return render(
        request,
        "blog/single_post_page.html",
        {
            "post": post,
        },
    )
```

## CVB에서의 템플릿
### PostList(ListView)
- 부모 클래스로써의 ListView는 기본적으로 `{모델명_list.html}`인 html파일을 찾아서 랜더링한다. 
	- 그래서 페이지 이름은 `index.html`--> `post_list.html`으로 바꾸고
- 또한 랜더링할 때 페이지로 전달할 변수 이름도 기본적으로 `{모델명_list}`로 전달한다. 
	- post_list.html안에 전달된 변수 이름도 `posts`에서 `post_list`로 버꿔야 함. 

### PostDetail(DetailView)
- 부모 클래스로써의 DetailView는 기본적으로 `{모델명_detail.html}`인 html파일을 찾아서 랜더링한다. 
	- 그래서 페이지 이름은 `single_post_page.html`--> `post_detail.html`으로 바꾸고
- 또한 랜더링할 때 페이지로 전달할 변수 이름도 기본적으로 `{모델명}`로 전달한다. 
	- post_list.html안에 전달된 변수 이름도 `post`로 설정해야 함. 
	

## 간단한 FrontEnd 함수 
### `{{일반 변수}}`

### for문

```html
{% for p in posts %}
        <hr/>
        <h2>{{ p.title }}</h2>
        <h4>{{ p.created_at }}</h4>
        <p>{{ p.content }}</p>
{% endfor %}
```


## DB ORM에 대한 함수 정리
### objects.all()

**ex: `Post.objects.all()`**

### objects.all().order_by("필드이름")

**ex: `Post.objects.all().order_by("-pk")`-> pk의 역순으로 정렬**

### objects.get(pk=변수 이름)

**ex: `Post.objects.get(pk=pk)` -> pk의 역순으로 정렬**

